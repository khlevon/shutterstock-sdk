# coding: utf-8

"""
    Shutterstock API Explorer

    The Shutterstock API provides access to Shutterstock's library of media, as well as information about customers' accounts and the contributors that provide the media.  # noqa: E501

    OpenAPI spec version: 1.1.3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class OauthApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def authorize(self, client_id, redirect_uri, response_type, state, **kwargs):  # noqa: E501
        """Authorize applications  # noqa: E501

        This endpoint returns a redirect URI (in the 'Location' header) that the customer uses to authorize your application and, together with POST /v2/oauth/access_token, generate an access token that represents that authorization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorize(client_id, redirect_uri, response_type, state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: Client ID (Consumer Key) of your application (required)
        :param str redirect_uri: The callback URI to send the request to after authorization; must use a host name that is registered with your application (required)
        :param str response_type: Type of temporary authorization code that will be used to generate an access code; the only valid value is 'code' (required)
        :param str state: Unique value used by the calling app to verify the request (required)
        :param str realm: User type to be authorized (usually 'customer')
        :param str scope: Space-separated list of scopes to be authorized
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.authorize_with_http_info(client_id, redirect_uri, response_type, state, **kwargs)  # noqa: E501
        else:
            (data) = self.authorize_with_http_info(client_id, redirect_uri, response_type, state, **kwargs)  # noqa: E501
            return data

    def authorize_with_http_info(self, client_id, redirect_uri, response_type, state, **kwargs):  # noqa: E501
        """Authorize applications  # noqa: E501

        This endpoint returns a redirect URI (in the 'Location' header) that the customer uses to authorize your application and, together with POST /v2/oauth/access_token, generate an access token that represents that authorization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorize_with_http_info(client_id, redirect_uri, response_type, state, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: Client ID (Consumer Key) of your application (required)
        :param str redirect_uri: The callback URI to send the request to after authorization; must use a host name that is registered with your application (required)
        :param str response_type: Type of temporary authorization code that will be used to generate an access code; the only valid value is 'code' (required)
        :param str state: Unique value used by the calling app to verify the request (required)
        :param str realm: User type to be authorized (usually 'customer')
        :param str scope: Space-separated list of scopes to be authorized
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'redirect_uri', 'response_type', 'state', 'realm', 'scope']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorize" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `authorize`")  # noqa: E501
        # verify the required parameter 'redirect_uri' is set
        if ('redirect_uri' not in params or
                params['redirect_uri'] is None):
            raise ValueError("Missing the required parameter `redirect_uri` when calling `authorize`")  # noqa: E501
        # verify the required parameter 'response_type' is set
        if ('response_type' not in params or
                params['response_type'] is None):
            raise ValueError("Missing the required parameter `response_type` when calling `authorize`")  # noqa: E501
        # verify the required parameter 'state' is set
        if ('state' not in params or
                params['state'] is None):
            raise ValueError("Missing the required parameter `state` when calling `authorize`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'client_id' in params:
            query_params.append(('client_id', params['client_id']))  # noqa: E501
        if 'realm' in params:
            query_params.append(('realm', params['realm']))  # noqa: E501
        if 'redirect_uri' in params:
            query_params.append(('redirect_uri', params['redirect_uri']))  # noqa: E501
        if 'response_type' in params:
            query_params.append(('response_type', params['response_type']))  # noqa: E501
        if 'scope' in params:
            query_params.append(('scope', params['scope']))  # noqa: E501
        if 'state' in params:
            query_params.append(('state', params['state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/html'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v2/oauth/authorize', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_access_token(self, **kwargs):  # noqa: E501
        """Get access tokens  # noqa: E501

        This endpoint returns an access token for the specified user and with the specified scopes. The token does not expire until the user changes their password. The body parameters must be encoded as form data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_access_token(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id:
        :param str client_secret:
        :param str code:
        :param str grant_type:
        :param str realm:
        :param str expires:
        :param str refresh_token:
        :return: OauthAccessTokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_access_token_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_access_token_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_access_token_with_http_info(self, **kwargs):  # noqa: E501
        """Get access tokens  # noqa: E501

        This endpoint returns an access token for the specified user and with the specified scopes. The token does not expire until the user changes their password. The body parameters must be encoded as form data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_access_token_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id:
        :param str client_secret:
        :param str code:
        :param str grant_type:
        :param str realm:
        :param str expires:
        :param str refresh_token:
        :return: OauthAccessTokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'client_secret', 'code', 'grant_type', 'realm', 'expires', 'refresh_token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_access_token" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'client_id' in params:
            form_params.append(('client_id', params['client_id']))  # noqa: E501
        if 'client_secret' in params:
            form_params.append(('client_secret', params['client_secret']))  # noqa: E501
        if 'code' in params:
            form_params.append(('code', params['code']))  # noqa: E501
        if 'grant_type' in params:
            form_params.append(('grant_type', params['grant_type']))  # noqa: E501
        if 'realm' in params:
            form_params.append(('realm', params['realm']))  # noqa: E501
        if 'expires' in params:
            form_params.append(('expires', params['expires']))  # noqa: E501
        if 'refresh_token' in params:
            form_params.append(('refresh_token', params['refresh_token']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v2/oauth/access_token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OauthAccessTokenResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_access_token(self, **kwargs):  # noqa: E501
        """Get access tokens  # noqa: E501

        This endpoint returns an access token for the specified user and with the specified scopes. The token does not expire until the user changes their password. The body parameters must be encoded as form data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_access_token(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OauthAccessTokenBody1 body:
        :return: OauthAccessTokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_access_token_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_access_token_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_access_token_with_http_info(self, **kwargs):  # noqa: E501
        """Get access tokens  # noqa: E501

        This endpoint returns an access token for the specified user and with the specified scopes. The token does not expire until the user changes their password. The body parameters must be encoded as form data.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_access_token_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param OauthAccessTokenBody1 body:
        :return: OauthAccessTokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_access_token" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'client_id' in params:
            form_params.append(('client_id', params['client_id']))  # noqa: E501
        if 'client_secret' in params:
            form_params.append(('client_secret', params['client_secret']))  # noqa: E501
        if 'code' in params:
            form_params.append(('code', params['code']))  # noqa: E501
        if 'grant_type' in params:
            form_params.append(('grant_type', params['grant_type']))  # noqa: E501
        if 'realm' in params:
            form_params.append(('realm', params['realm']))  # noqa: E501
        if 'expires' in params:
            form_params.append(('expires', params['expires']))  # noqa: E501
        if 'refresh_token' in params:
            form_params.append(('refresh_token', params['refresh_token']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/x-www-form-urlencoded', 'application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v2/oauth/access_token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OauthAccessTokenResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
